#! /usr/bin/env python

# main script to run FUCHS

def main():

    # required packages
    import os
    import argparse

    parser = argparse.ArgumentParser(description='Main script of the FUCHS pipeline.'
                                                 'For a detailed help see https://github.com/dieterich-lab/FUCHS '
                                                 'or the included README.rst file.')

    # input
    parser.add_argument('-C', dest='circlefile', default = 'none',
			help='Tab-separated file chr:start_end(tab)read1,read2,read3.')
    parser.add_argument('-DCC', dest='CircRNACount', default='none',
                        help='If you mapped with STAR and are using step1 you need to provide a list'
                             ' of circle ids (CircRNACount or CircCoordinates from DCC)'
                             'You must supply either -C or -DCC')    
    parser.add_argument('-CJ', '--chimericJunctions', dest='chimeric_junction', default='none',
                        help='If you mapped with STAR and are using step1 you need to provide the paired end Chimeric.junction.out file here')
    parser.add_argument('-m1', '--mate1', dest='mate1', default='none',
                        help='If you mapped with STAR and are using step1 you need to provide the mate1.Chimeric.junction.out file here (optional if ends were mapped separately)')
    parser.add_argument('-m2', '--mate2', dest='mate2', default='none',
                        help='If you mapped with STAR and are using step1 you need to provide the mate2.Chimeric.junction.out file here (optional if ends were mapped separately)')
    parser.add_argument('-BAM', dest='bamfile', required = True,
                        help='BAM file containing chimeric reads, linear reads may be in it but are not required.')
    parser.add_argument('-BED', dest='bedfile', required = True,
			help='bed formatted feature file including exons.')
    # output
    parser.add_argument('-OUT', dest='out_folder', default = '.',
                        help='Output folder. There will be a sub folder for the sample containing a BAM file '
                             'for each circle.')
    parser.add_argument('-sample', dest='sample', required = True, 
			help='sample name to title every thing.')

    # options
    parser.add_argument('-r', dest='reads', default=5, type=int,
                        help='Circle has to have at least <r> reads to be analysed.')

    #TODO: default: no multi map
    parser.add_argument('-q', dest='mapq', default=3, type=int,
                        help='MAPQ cutoff, only reads passing this threshold will be written to circle BAM file.')
    #TODO: add 0 based info
    parser.add_argument('-s', dest='split_character', default='_', help='feature name separator.')
    parser.add_argument('-e', dest='exon_index', default=3, type=int,
                        help='Field indicating the exon number after splitting feature name by split_character (for the annotation file).')
    parser.add_argument('-p', dest='ref_platform', default='refseq',
                        help='Specifies the annotation platform which was used (refseq or ensembl)')
    parser.add_argument('-sS', dest='skipped_steps', default='none',
                        help='Comma separated list of steps that should be skipped (e.g. step3,step4,step6)')
    parser.add_argument('--tmp', dest='tmp_folder', default='/tmp/',
                        help='Folder to store temporary files generated by pybedtools.')

    args = parser.parse_args()

    # parse arguments
    circles = os.path.expanduser(args.circlefile)
    circle_ids = os.path.expanduser(args.CircRNACount)
    paired = os.path.expanduser(args.chimeric_junction) # not the greatest naming scheme
    junctionfile = os.path.expanduser(args.mate1) # not the greatest naming scheme
    mates = os.path.expanduser(args.mate2) # not the greatest naming scheme
    bamfile = os.path.expanduser(args.bamfile)
    bedfile = os.path.expanduser(args.bedfile)
    outfolder = os.path.expanduser(args.out_folder)
    sample = args.sample
    
    cutoff_reads = args.reads
    cutoff_mapq = args.mapq
    exon_index = args.exon_index
    split_character = args.split_character
    platform = args.ref_platform
    skipped_steps = args.skipped_steps.split(',')
    tmp_folder = os.path.expanduser(args.tmp_folder)
    
    # make log file
    # TODO
    # test if command line was correct
    if circles == 'none' and circle_ids == 'none':
	print('ERROR, you need to specify either a -C or -DCC.\nIf you mapped and detected your circRNAs with STAR/DCC you may indicate \n-DCC CircRNACount, -CJ Chimeric.junction.out, -m1 mate1.Chimeric.junction.out and -m2 mate2.Chimeric.junction.out\nif you used a different program, please supply a circID list using -C.\n' )
	quit()
    
    if not circles == 'none' and not circle_ids == 'none':
	print('You have indicated both -C and -DCC, this is not necessary, we will skip step1 (read extraction from the STAR output) and proceed with the circID file\n')
	circle_ids == 'none'
	skipped_steps += ['step1']
    
    if not circle_ids == 'none' and paired == 'none':
	print('You have indicated that you detected your circRNAs using STAR/DCC with the -DCC flag, \nhowever you did not specify a Chimeric.junction.out file, this is necessary, \nplease specify at least -CJ, if you have paired end data also specify -m1/-m2\n')
	quit()

    # convert relative paths names to absolute path names
    working_dir = os.getcwd()
    if not circles == 'none' and not os.path.isabs(circles):
	circles = os.path.abspath(os.path.join(os.getcwd(), circles))
	print('changed circID file to %s\n' %(circles))
    if not circles == 'none' and not os.path.exists(circles):
	print('ERROR, no such file or directory: %s' %(circles))
	quit()
    
    if not circle_ids == 'none' and not os.path.isabs(circle_ids):
	circle_ids = os.path.abspath(os.path.join(os.getcwd(), circle_ids))
	print('changed CircRNACount file to %s\n' %(circle_ids))
    if not circle_ids == 'none' and not os.path.exists(circle_ids):
	print('ERROR, no such file or directory: %s' %(circle_ids))
	quit()
	
    if not paired == 'none' and not os.path.isabs(paired):
	paired = os.path.abspath(os.path.join(os.getcwd(), paired))
	print('changed Chimeric.junction.out file to %s\n' %(paired))
    if not paired == 'none' and not os.path.exists(paired):
	print('ERROR, no such file or directory: %s' %(paired))
	quit()
    
    if not mates == 'none' and not os.path.isabs(mates):
	mates = os.path.abspath(os.path.join(os.getcwd(), mates))
	print('changed mate2.Chimeric.junction.out file to %s\n' %(mates))
    if not mates == 'none' and not os.path.exists(mates):
	print('ERROR, no such file or directory: %s' %(mates))
	quit()

    if not junctionfile == 'none' and not os.path.isabs(junctionfile):
	junctionfile = os.path.abspath(os.path.join(os.getcwd(), junctionfile))
	print('changed mate1.Chimeric.junction.out file to %s\n' %(junctionfile))
    if not junctionfile == 'none' and not os.path.exists(junctionfile):
	print('ERROR, no such file or directory: %s' %(junctionfile))
	quit()
    
    if not os.path.isabs(bamfile):
	bamfile = os.path.abspath(os.path.join(os.getcwd(), bamfile))
	print('changed bamfile file to %s\n' %(bamfile))
    if not os.path.exists(bamfile):
	print('ERROR, no such file or directory: %s' %(bamfile))
	quit()
	
    if not os.path.isabs(outfolder):
	outfolder = os.path.abspath(os.path.join(os.getcwd(), outfolder))
	print('changed output folder to %s\n' %(outfolder))
    if not os.path.exists(outfolder):
	print('ERROR, no such file or directory: %s' %(outfolder))
	quit()
	
    if not os.path.isabs(tmp_folder):
	tmp_folder = os.path.abspath(os.path.join(os.getcwd(), tmp_folder))
	print('changed tmp folder to %s\n' %(tmp_folder))
    if not os.path.exists(tmp_folder):
	print('ERROR, no such file or directory: %s' %(tmp_folder))
	quit()
	
    if not os.path.isabs(bedfile):
	bedfile = os.path.abspath(os.path.join(os.getcwd(), bedfile))
	print('changed bedfile file to %s\n' %(bedfile))
    if not os.path.exists(bedfile):
	print('ERROR, no such file or directory: %s' %(bedfile))
	quit()
	
    
    #test platform
    accepted_platforms = ('refseq', 'ensembl')
    platform = platform.lower()
    if not platform in accepted_platforms:
        print('ERROR please specify an accepted annotation platform. Possible options are: refseq or ensembl')
        quit()
    
    print "The following analysis steps will be skipped: " + '%s' % ', '.join(map(str, skipped_steps))

    # Step 1: (optional) if DCC was used, extract circle read names from junction file 
    if not 'step1' in skipped_steps:

        circles = "%s.reads.txt" % junctionfile
        import get_readnames_from_DCC as get_readnames
        names = get_readnames.get_readnames_from_DCC(mates, circle_ids, junctionfile)
        names.run()

    # Step2 : extract circle reads from sample bam file
    if not 'step2' in skipped_steps:

        import extract_reads as extract_reads
        er = extract_reads.extract_reads(cutoff_reads, cutoff_mapq, circles, bamfile, outfolder, sample, tmp_folder)
        er.run()

    # Step3 : (optional) get information about possibly rolling circles 
    if not 'step3' in skipped_steps:

        import get_mate_information as mateinformation
        mi = mateinformation.mate_information(platform, split_character, bedfile, outfolder, sample, tmp_folder)
        mi.run()

    # Step4 : (optional) find exon skipping events
    if not 'step4' in skipped_steps:

        import detect_skipped_exons as skipped_exons
        se = skipped_exons.detect_skipped_exons(outfolder, sample, bedfile, tmp_folder, platform)
        se.run()

    # Step5 : (optional) identify different circles within the same host gene
    if not 'step5' in skipped_steps:

        import detect_splicing_variants as splicing_variants
        sv = splicing_variants.detect_splicing_variants(split_character, platform, circles, bedfile,
                                                        outfolder, sample, tmp_folder)
        sv.run()

    # Step6 : (optional) generate coverage profile for each circle
    # (one transcript per gene, best if most fitting transcript)
    if not 'step6' in skipped_steps:
        # os.system('python get_coverage_profile.py -e %s -s %s -p %s %s %s %s --tmp %s' %
        #           (exon_index, split_character, platform, bedfile, outfolder, sample, tmp_folder))

        import get_coverage_profile as coverage_profile
        sv = coverage_profile.get_coverage_profile(exon_index, split_character, platform, bedfile,
                                                   outfolder, sample, tmp_folder)
        sv.run()

    # Step7 : (optional, requires step 5)
    if not 'step7' in skipped_steps:
        if not 'step6' in skipped_steps:

            os.system('summarized_coverage_profiles.R %s/%s.coverage_profiles' % (outfolder, sample))
        else:
            print('You are trying cluster the coverage profiles without '
                  'generating coverage profiles first, please run step 5')

    # Step8 : (optional, requires step6) pictures for all circles
    if not 'step8' in skipped_steps:
        if not 'step6' in skipped_steps:
            files = os.listdir('%s/%s.coverage_profiles' % (outfolder, sample))
            folders = os.listdir(outfolder)
            if not '%s.coverage_pictures' % (sample) in folders:
                os.mkdir('%s/%s.coverage_pictures' % (outfolder, sample))
            for f in files:
                if f.endswith('.txt'):
                    print('Generating plot for %s' % f)
                    os.system('make_coverage_picture.R %s/%s.coverage_profiles/%s %s/%s.coverage_pictures/' %
                              (outfolder, sample, f, outfolder, sample))
        else:
            print('You are trying to generate coverage pictures '
                  'without generating coverage profiles, please run step 5')

if __name__ == '__main__':
    main()
